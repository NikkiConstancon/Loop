{
  "name": "dse-driver",
  "version": "1.2.0",
  "description": "DataStax Enterprise Node.js Driver",
  "author": {
    "name": "DataStax"
  },
  "keywords": [
    "cassandra",
    "cql",
    "cql3",
    "connection",
    "gremlin",
    "datastax",
    "nosql",
    "driver",
    "database",
    "dse",
    "graph",
    "graphdb"
  ],
  "dependencies": {
    "cassandra-driver": "^3.2.0"
  },
  "devDependencies": {
    "mocha": ">= 1.14.0",
    "rewire": ">= 2.1.0",
    "mocha-jenkins-reporter": ">= 0.1.9",
    "temp": ">= 0.8.3"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/datastax/nodejs-driver-dse.git"
  },
  "bugs": {
    "url": "https://groups.google.com/a/lists.datastax.com/forum/#!forum/nodejs-driver-user"
  },
  "license": "SEE LICENSE IN http://www.datastax.com/terms/datastax-dse-driver-license-terms",
  "scripts": {
    "test": "./node_modules/.bin/mocha test/unit -R spec -t 5000",
    "ci": "./node_modules/.bin/mocha test/unit test/integration -R mocha-jenkins-reporter"
  },
  "engines": {
    "node": ">=0.10.0"
  },
  "readme": "# DataStax Enterprise Node.js Driver\n\nThis driver is built on top of [Node.js CQL driver for Apache Cassandra][cassandra-driver] and provides the following\nadditions for [DataStax Enterprise][dse]:\n\n* `Authenticator` implementations that use the authentication scheme negotiation in the server-side `DseAuthenticator`;\n* encoders for geospatial types which integrate seamlessly with the driver;\n* DSE graph integration.\n\nThe DataStax Enterprise Node.js Driver can be used solely with DataStax Enterprise. Please consult\n[the license](#license).\n\n## Installation\n\n```bash\nnpm install dse-driver\n```\n\n[![Build Status](https://travis-ci.org/datastax/nodejs-driver-dse.svg?branch=master)](https://travis-ci.org/datastax/nodejs-driver-dse)\n\n## Documentation\n\n- [Documentation index][doc-index]\n- [API docs][api-docs]\n- [FAQ][faq]\n\n## Getting Help\n\nYou can use the [project mailing list][mailing-list] or create a ticket on the [Jira issue tracker][jira]. \n\n## Getting Started\n\n`Client` inherits from the CQL driver counterpart `Client`.  All CQL features available to  `Client` (see the\n[CQL driver manual][core-manual]) can also be used with `Client`.\n\n```javascript\nconst dse = require('dse-driver');\nconst client = new dse.Client({ contactPoints: ['host1', 'host2'] });\n\nconst query = 'SELECT name, email FROM users WHERE key = ?';\nclient.execute(query, [ 'someone' ])\n  .then(result => console.log('User with email %s', result.rows[0].email));\n```\n\nAlternatively, you can use the callback-based execution for all asynchronous methods of the API.\n\n```javascript\nclient.execute(query, [ 'someone' ], function(err, result) {\n  assert.ifError(err);\n  console.log('User with email %s', result.rows[0].email);\n});\n```\n\nThe `dse-driver` module also exports the submodules from the CQL driver, so you only need to import one module to access\nall DSE and Cassandra types.\n\nFor example:\n```javascript\nconst dse = require('dse-driver');\nconst Uuid = dse.types.Uuid;\n```\n\n## Authentication\n\nFor clients connecting to a DSE cluster secured with `DseAuthenticator`, two authentication providers are included:\n\n* `DsePlainTextAuthProvider`: Plain-text authentication;\n* `DseGSSAPIAuthProvider`: GSSAPI authentication;\n\nTo configure a provider, pass it when initializing a cluster:\n\n```javascript\nconst dse = require('dse-driver');\nconst client = new dse.Client({\n  contactPoints: ['h1', 'h2'], \n  keyspace: 'ks1',\n  authProvider: new dse.auth.DseGssapiAuthProvider()\n});\n```\n\nSee the jsdoc of each implementation for more details.\n\n## Graph\n\n`Client` includes the `executeGraph()` method to execute graph queries:\n\n```javascript\nconst client = new dse.Client({\n  contactPoints: ['host1', 'host2'],\n  profiles: [\n    new ExecutionProfile('default', {\n      graphOptions: { name: 'demo' }\n    })\n  ]\n});\n\n// executeGraph() method returns a Promise\nconst result = await client.executeGraph('g.V()');\nconst vertex = result.first();\nconsole.log(vertex.label);\n```\n\n### Graph Options\n\nYou can set graph options in execution profiles when initializing `Client`. Also, to avoid providing the graph name\noption in each `executeGraph()` call, you can set the graph options in the default execution profile:\n\n```javascript\nconst client = new dse.Client({\n  contactPoints: ['host1', 'host2'],\n  profiles: [\n    new ExecutionProfile('default', {\n      graphOptions: { name: 'demo' }\n    }),\n    new ExecutionProfile('demo2-profile', {\n      graphOptions: { name: 'demo2' }\n    })\n  ]\n});\n```\n```javascript\n// Execute a traversal on the 'demo' graph\nconst result = await client.executeGraph(query, params);\n```\n\nIf needed, you can specify an execution profile different from the default one: \n\n```javascript\n// Execute a traversal on the 'demo2' graph\nclient.executeGraph(query, params, { executionProfile: 'demo2-profile'});\n```\n\nAdditionally, you can also set the default graph options without using execution profiles (not recommended). \n\n```javascript\nconst client = new dse.Client({\n  contactPoints: ['host1', 'host2'],\n  graphOptions: { name: 'demo' }\n});\n```\n\n### Handling Results\n\nGraph queries return a `GraphResultSet`, which is an [iterable][iterable] of rows. The format of the data returned is\ndependent on the data requested.  For example, the payload representing edges will be different than those that\nrepresent vertices using the ['modern'][modern-graph] graph:\n\n```javascript\n// Creating the 'modern' graph\nconst query =\n  'Vertex marko = graph.addVertex(label, \"person\", \"name\", \"marko\", \"age\", 29);\\n' +\n  'Vertex vadas = graph.addVertex(label, \"person\", \"name\", \"vadas\", \"age\", 27);\\n' +\n  'Vertex lop = graph.addVertex(label, \"software\", \"name\", \"lop\", \"lang\", \"java\");\\n' +\n  'Vertex josh = graph.addVertex(label, \"person\", \"name\", \"josh\", \"age\", 32);\\n' +\n  'Vertex ripple = graph.addVertex(label, \"software\", \"name\", \"ripple\", \"lang\", \"java\");\\n' +\n  'Vertex peter = graph.addVertex(label, \"person\", \"name\", \"peter\", \"age\", 35);\\n' +\n  'marko.addEdge(\"knows\", vadas, \"weight\", 0.5f);\\n' +\n  'marko.addEdge(\"knows\", josh, \"weight\", 1.0f);\\n' +\n  'marko.addEdge(\"created\", lop, \"weight\", 0.4f);\\n' +\n  'josh.addEdge(\"created\", ripple, \"weight\", 1.0f);\\n' +\n  'josh.addEdge(\"created\", lop, \"weight\", 0.4f);\\n' +\n  'peter.addEdge(\"created\", lop, \"weight\", 0.2f);';\n\nawait client.executeGraph(query);\n```\n\n```javascript\n// Handling Edges\nconst result = await client.executeGraph('g.E()');\nresult.forEach(function (edge) {\n  console.log(edge.id); // [an internal id representing the edge]\n  console.log(edge.type); // edge\n  console.log(edge.label); // created\n  console.log(edge.properties.weight); // 0.4\n  console.log(edge.outVLabel); // person\n  console.log(edge.outV); // [an id representing the outgoing vertex]\n  console.log(edge.inVLabel); // software\n  console.log(edge.inV); // [an id representing the incoming vertex]\n});\n```\n\n```javascript\n// Using ES6 for...of\nconst result = await client.executeGraph('g.E()');\nfor (let edge of result) {\n  console.log(edge.label); // created\n  // ...\n}\n```\n\n```javascript\n// Handling Vertices\nconst result = await client.executeGraph('g.V().hasLabel(\"person\")');\nresult.forEach(function(vertex) {\n  console.log(vertex.id); // [an internal id representing the vertex]\n  console.log(vertex.type); // vertex\n  console.log(vertex.label); // person\n  console.log(vertex.properties.name[0].value); // marko\n  console.log(vertex.properties.age[0].value); // 29\n});\n```\n\n### Parameters\n\nUnlike CQL queries which support both positional and named parameters, graph queries only support named parameters.\nAs a result of this, parameters must be passed in as an object:\n\n```javascript\nconst query = 'g.addV(label, vertexLabel, \"name\", username)';\nconst result = await client.executeGraph(query, { vertexLabel: 'person', username: 'marko' });\nconst vertex = result.first();\n// ...\n```\n\nParameters are encoded in json, thus will ultimately use their json representation (`toJSON` if present,\notherwise object representation).\n\nYou can use results from previous queries as parameters to subsequent queries.  For example, if you want to use the id\nof a vertex returned in a previous query for making a subsequent query:\n\n```javascript\nlet result = await client.executeGraph('g.V().hasLabel(\"person\").has(\"name\", \"marko\")');\nconst vertex = result.first();\nresult = await client.executeGraph('g.V(vertexId).out(\"knows\").values(\"name\")', { vertexId: vertex.id });\nconst names = result.toArray();\nconsole.log(names); // [ 'vadas', 'josh' ]\n```\n\n### Prepared graph statements\n\nPrepared graph statements are not supported by DSE Graph yet (they will be added in the near future).\n\n## Geospatial types\n\nDSE 5.0 comes with a set of additional CQL types to represent geospatial data: `PointType`, `LineStringType` and\n`PolygonType`.\n\n```\ncqlsh> CREATE TABLE points_of_interest(name text PRIMARY KEY, coords 'PointType');\ncqlsh> INSERT INTO points_of_interest (name, coords) VALUES ('Eiffel Tower', 'POINT(48.8582 2.2945)');\n```\n\nThe DSE driver includes encoders and representations of these types in the `geometry` module that can be used directly\nas parameters in queries:\n\n```javascript\nconst dse = require('dse-driver');\nconst Point = dse.geometry.Point;\nconst insertQuery = 'INSERT INTO points_of_interest (name, coords) VALUES (?, ?)';\nconst selectQuery = 'SELECT coords FROM points_of_interest WHERE name = ?';\n\nawait client.execute(insertQuery, [ 'Eiffel Tower', new Point(48.8582, 2.2945) ], { prepare: true });\nconst result = await client.execute(selectQuery, ['Eiffel Tower'], { prepare: true });\nconst row = result.first();\nconst point = row['coords'];\nconsole.log(point instanceof Point); // true\nconsole.log('x: %d, y: %d', point.x, point.y); // x: 48.8582, y: 2.2945\n```\n\n## License\n\nCopyright 2016 DataStax\n\nhttp://www.datastax.com/terms/datastax-dse-driver-license-terms\n\n\n[dse]: http://www.datastax.com/products/datastax-enterprise\n[cassandra-driver]: https://github.com/datastax/nodejs-driver\n[core-manual]: http://docs.datastax.com/en/developer/nodejs-driver/latest/\n[iterable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable\n[modern-graph]: http://tinkerpop.apache.org/docs/3.1.1-incubating/reference/#_the_graph_structure\n[jira]: https://datastax-oss.atlassian.net/projects/NODEJS/issues\n[mailing-list]: https://groups.google.com/a/lists.datastax.com/forum/#!forum/nodejs-driver-user\n[doc-index]: http://docs.datastax.com/en/developer/nodejs-driver-dse/latest/\n[api-docs]: http://docs.datastax.com/en/latest-dse-nodejs-driver-api/\n[faq]: http://docs.datastax.com/en/developer/nodejs-driver-dse/latest/faq/\n",
  "readmeFilename": "README.md",
  "_id": "dse-driver@1.2.0",
  "_from": "dse-driver@~1.2.0"
}
